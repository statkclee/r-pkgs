---
title: Namespaces
layout: default
output: bookdown::html_chapter
---

# 네임스페이스(Namespace) {#namespace}

(`NAMESPACE` 파일에 기록되는) 팩키지 네임스페이스는 팩키지를 작성할 때 혼동스러운 부분 중에 하나다.
네임스페이스는 상당히 고급 주제로 대체로 본인이 사용할 팩키지만 개발한다면 그다지 중요하지는 않다.
하지만, 팩키지를 제출할 계획을 갖고 있다면, 네임스페이스를 이해하는 것이 꼭 필요하다.
이유는 CRAN에서 작성한 팩키지가 다른 팩키지와 멋지게 동작하도록 요구하기 때문이다.

처음 네임스페이스를 사용하기 시작하면 얻는 것에 비해 들어가는 작업이 엄청난 것처럼 느껴진다.
하지만, 고품질 네임스페이를 획득하면 팩키지를 캡슐화하고 그 자체로 완비된 팩키지가 되게 한다.
이를 통해 다른 팩키지가 본인 코드를 방해하지 못하게 하고, 본인 코드도 다른 팩키지를 침범하지 않게 하고,
실행 환경에 관계없이 팩키지가 동작되게 확실히 한다.


## 동기 {#namespace-motivation}

명칭에서 알 수 있듯이, 네임스페이스(namespace)는 "명칭(names)"에 대한 "공간(space)"을 제공한다.
명칭과 연관된 객체 값을 조회하는데 있어 맥락(context)을 제공한다.

부지불식 중에 아마도 네임스페이스를 이미 사용했다.
예를 들어, `::` 연산자를 사용했지요?
동일한 명칭을 갖는 함수의 모호성을 제거한다.
예를 들어, `plyr`, `Hmisc` 팩키지 모두 `summarize()` 함수를 제공한다.
만약 `plyr`을 로드하고 나서, `Hmisc`를 로드하면, `summarize()` 함수는 Hmisc 버젼을 참조한다.
하지만, 역순으로 로드하면, `summarize()` 함수는 dplyr 버젼을 참조한다.
이러한 면이 혼란스러울 수 있다.
대신에 명시적으로 특정 함수를 참조할 수 있다: `Hmisc::summarize()`, `plyr::summarize()`.
그러고 나면, 팩키지가 적재되는 순서는 문제가 되지 않는다.

네임스페이스는 두가지 방식으로 팩키지를 스스로 완비되게 만든다: __가져오기(imports)__, __내보내기(exports)__.
__가져오기(imports)__는 특정 팩키지에 있는 함수를 또다른 팩키지에 있는 함수를 찾는 방법을 정의한다.
시연 목적으로, 누군가 참조하고 있는 함수 정의를 변경했을 때 무슨 일이 발생하는지 생각해보자: R 베이스(base) 간단한 `nrow()` 함수를 예를 들어보자:
  
```{r}
nrow
```

`nrow()` 함수는 `dim()` 함수로 정의된다. 
그래서 만약 `dim()` 함수를 사용자 정의로 재정의(override)하면 무슨 일이 발생할까요?
`nrow()` 함수가 망가질까요?


```{r}
dim <- function(x) c(1, 1)
dim(mtcars)
nrow(mtcars)
```

놀랍게도 망가지지 않아요! 이유는 `nrow()` 함수가 `dim()`로 불리는 객체를 찾을 때, 팩키지 네임스페이스를
사용해서 베이스 실행환경에 있는 `dim()` 함수를 찾기 때문이다. 전역 환경에서 사용자가 생성한 `dim()` 함수를 찾는게 아니다.

__내보내기(exports)__는 어떤 함수를 팩키지 외부에 노출시킬지 명시함으로써
다른 팩키지와 충돌을 회피하게 돕는다 (내부 함수는 팩키지 내부에서만 이용가능하고 다른 팩키지가 쉽게 사용할 수 없다). 일반적으로, 최소 함수 집합만 내보내고 싶을 것이다: 적게 내보낼수록, 충돌가능성은 작아진다.
충돌 문제로 세상이 끝나는 것은 아닌 것은 `::`을 사용해서 항상 모호성을 제거할 수 있기 때문이다.
충돌은 가능하면 최선을 다해 피해야 되는데, 팩키지 사용자 삶을 더 쉽게 만들기 때문이다.

## 검색 경로 (Search path) {#search-path}

네임스페이스 중요성을 이해하기 위해서는 검색 경로(search path)에 대한 확고한 이해가 필요하다. 함수를 호출하면, R이 함수를 찾아야 한다.
R은 먼저 전역 환경(global environment)을 뒤져 탐색을 시작한다.
만약 전역 환경에서 찾지 못한다면, 검색 경로를 뒤진다. 
검색 경로에는 사용자가 __부착한(attached)__ 모든 팩키지 목록 정보가 담겨있다.
`search()` 명령어를 실행해서 해당 목록정보를 확인할 수 있다.
예를 들어, 다음에 이 책을 저술하는데 사용된 코드에 대한 검색경로가 나와 있다:  

```{r}
search()
```

팩키지 적재(loading)와 부착(attaching) 사이에는 중요한 차이점이 있다.
일반적으로 팩키지를 적재한다고 얘기할 때 `library()`를 생각하지만,
사실은 팩키지를 부착하는 것이다.

만약 팩키지가 설치되었다면,

* __적재(Loading)__는 코드, 데이터, DLLs 파일을 적재해서 올린다; 
  S3, S4 메쏘드를 등록하고 `.onLoad()` 함수를 실행한다.
  적재된 후에 팩키지는 메모리에 상주하여 이용가능하지만, 
  검색경로에 있지 않기 때문에, `::` 없이 해당 컴포넌트에 접근할 수 없다.
  혼동스럽게도, `::`도 만약 팩키지가 적재되지 않았다면 자동으로 팩키지를 적재한다.
  팩키지를 명시적으로 적재하는 않지만, 
  `requireNamespace()` 혹은 `loadNamespace()`을 사용해서 적재하기도 한다.


* __부착(Attaching)__은 팩키지를 검색경로에 놓는다.
  팩키지를 먼저 적재하지 않고 팩키지를 부착할 수는 없다.
  그래서, `library()` 혹은 `require()` 명령어는 적재하고 나서 팩키지를 부착한다.
  `search()` 명령어로 현재 부착된 팩키지를 살펴볼 수 있다.

만약 팩키지가 설치되어 있지 않다면, 적재(그리고 나서 부착)를 하면 오류가 나서 정상 실행되지 않는다.

좀더 명확하게 차이점을 살펴보기 위해서,
`testthat` 팩키지로부터 `expect_that()`을 실행하는 두가지 방법을 고려해보자.
만약 `library()`를 사용하면, `testthat`은 검색경로에 부착된다.
만약 `::`을 사용하면, `testthat`은 검색경로에 부착되지 않는다.


```{r, error = TRUE}
old <- search()
testthat::expect_equal(1, 1)
setdiff(search(), old)
expect_true(TRUE)
    
library(testthat)
expect_equal(1, 1)
setdiff(search(), old)
expect_true(TRUE)
```

팩키지를 이용가능하게 만드는 함수가 4개 있다.
적재되거나 부착되느냐에 따라, 그리고 팩키지가 검색되지 않았을 때 발생되는 사건(즉, 오류를 던지느냐 혹은 FALSE를 반환하느냐)에 따라 차이점이 생긴다.


|              | 오류 생성(Throws error) |    `FALSE` 반환                           |
|--------------|-------------------------|-------------------------------------------|
| 적재(Load)   |  `loadNamespace("x")`   | `requireNamespace("x", quietly = TRUE)`   |
| 부착(Attach) |  `library(x)`           | `require(x, quietly = TRUE)`              |

4가지 경우 중에서, 오직 두가지만 사용한다:


* 자료분석 스크립트로 `library(x)`을 사용한다.
  만약 팩키지가 설치되어 있지 않다면 오류를 던지고 스크립트를 종료한다.
  적게 타이핑을 하려면 팩키지를 부착한다.
  팩키지에 절대로 `library()`를 사용하지 마라.
  

* 추천 팩키지 설치 여부에 따라 특정 동작(예를 들어, 오류 발생)을
  구현하고자 한다면, 팩키지 내부에서 `requireNamespace(x, quietly = TRUE)`를 사용한다.
  
`require()` (왜냐하면, `requireNamespace()`가 거의 항상 더 좋다) 혹은 `loadNamespace()` (왜냐하면 내부 R 코드에만 필요하다)는 절대로 사용할 필요가 없다.
팩키지 내부에서 `require()` 혹은 `library()` 는 절대 사용하지 말라:
대신에, `DESCRIPTION` 파일에 `Depends` 혹은 `Imports` 필드를 사용한다.

앞에서 얼버무리고 넘어갔던 중요한 이슈로 돌아올 적절한 시점이 되었다.
`DESCRIPTION` 파일에서 `Depends` 와 `Imports` 간 차이가 뭘까요?
어느 시점에 `Depends`를 또 다른 시점에는 `Imports`를 사용해야 할까요?

`Depends` 혹은 `Imports`에 팩키지 목록을 작성하면 필요할 때 팩키지가 확실히 설치되게 한다. 주된 차이점은 `Imports`는 단지 팩키지를 _적재(load)_하는 반면,
`Depends`는 팩키지를 _부착(attach)_한다. 다른 차이점은 없다.
이 장에서 나머지 조언은 팩키지에 `Depends` 혹은 `Imports`를 적용할지 말지다.

특별한 다른 사유가 없다면, 항상 `Depends`가 아닌 `Imports`에 팩키지 목록을 올려야 된다.
이유는 훌륭한 팩키지는 그자체로 완비되고 (검색경로를 포함해서) 전역 환경에 변경을 최소화한다. 유일한 예외는 팩키지가 또다른 팩키지와 결합되어 사용되도록 설계되었을 때다. 예를 들어, [analogue](https://github.com/gavinsimpson/analogue) 팩키지는 [vegan](https://github.com/vegandevs/vegan) 팩키지 기반으로 개발되었다. `vagan` 없이는 유용하게 사용될 수 없기 때문에, `Imports` 대신에 vagan을 `Depends`에 넣는다.
마찬가지로 `ggplot2`는 `scales`를 `Import` 하는 대신에, 정말 `Depend` 해야 된다.

네임스페이스의 중요성에 대해서 이해했기 때문에, 핵심 사항으로 바로 들어가 보자.
팩키지 네임스페이스 양쪽면, 즉 imports 와 exports는 `NAMESPACE`에 기술된다.
다음 절에서 해당 파일 어떻게 생겼는지 학습할 것이다.
그 다음 절에서는 함수와 관련 객체를 가져오고(import) 내보내는(export) 상세한 점을 학습할 것이다.


## `NAMESPACE` {#NAMESPACE}

다음 코드는 `testthat` 팩키지로부터 나온 `NAMESPACE` 파일을 발췌한 것이다.

    # Generated by roxygen2 (4.0.2): do not edit by hand
    S3method(as.character,expectation)
    S3method(compare,character)
    export(auto_test)
    export(auto_test_package)
    export(colourise)
    export(context)
    exportClasses(ListReporter)
    exportClasses(MinimalReporter)
    importFrom(methods,setRefClass)
    useDynLib(testthat,duplicate_)
    useDynLib(testthat,reassign_function)

`NAMESPACE` 파일이 R 코드처럼 생긴 것을 볼 수 있다.
각 행에는 __지시어(directive)__가 포함되어 있다: `S3method()`, `export()`, `exportClasses()`, 등등.
각 지시어는 R 객체를 기술하고, 팩키지에서 내보내서 다른 사용자들이 사용하게 할지, 다른 팩키지에서 가져와서 로컬 컴퓨터에서 사용할지 표현하고 있다.

전체로 보면, 8개 네임스페이스 지시어가 있다. 그중 4개는 내보내기(export)를 기술한다:

* `export()`: 내보내기 함수 (S3 와 S4 제네릭 포함).
* `exportPattern()`: 패턴과 매칭되는 모든 함수를 내보내기.
* `exportClasses()`, `exportMethods()`: S4 클래스와 메쏘드를 내보낸다.
* `S3method()`: S3 메쏘드를 내보낸다.

그리고, 나머지 4개는 가져오기(import)를 기술한다:

* `import()`: 팩키지로부터 모든 함수를 가져온다.
* `importFrom()`: 선택 함수만 가져온다. (S4 제네릭 포함).
* `importClassesFrom()`, `importMethodsFrom()`: S4 클래스와 메쏘드 가져오기.
* `useDynLib()`: C 로부터 함수를 가져오기. 
  [compiled code](#src)에서 좀더 자세한 사항이 기술된다.

수작업으로 지시어를 작성하는 것을 저자는 추천하지 않는다.
대신에 이번 장에서 `roxygen2`로 `NAMESPACE`를 생성하는 방법을 학습할 것이다.
`roxygen2`를 사용하는 세가지 장점이 있다:

* 네임스페이스 정의는 연관된 함수 바로 옆에 위치한다. 
  그래서 코드를 읽을 때, 어떤 팩키지를 가져오고 내보내는지 확인하기 더 쉽다.

* Roxygen2를 통해서 `NAMESPACE` 구체적인 사항 일부를 추상화해서 없애버린다.
  `@export` 태그만 배우면, 나머지는 알아서 함수, S3 메쏘드, S4 메쏘드, S4 클래스에 
  대한 적절한 지시어를 자동으로 생성해준다.


* Roxygen2가 `NAMESPACE`를 깜끔하게 만든다.
  `@importFrom foo bar`을 얼마나 많이 사용하는지 관계없이,
  `NAMESPACE`에는 단 하나의 `importFrom(foo, bar)`이 존재한다.
  한 중심장소에서 관리하기 보다는, 
  지시어가 필요한 모든 함수에 가져오기 지시어를 부착하기 쉽게 한다.

`roxygen2`를 사용해서 `NAMESPACE`만, 혹은 `man/*.Rd`만, 혹은 양쪽 모두 생성할 수 있다는 점에 주목한다. 만약 어떠한 네임스페이스 관련된 태그를 사용하지 않는다면, `roxygen2`는 
`NAMESPACE`에 일절 손대지 않는다. 만약 어떤 문서화 관련된 태그도 사용하지 않는다면, 
`roxygen2`는 `man/`에 일절 손대지 않는다.

## 작업흐름 {#namespace-workflow}

`roxygen2`로 네임스페이스를 생성하는 것은 `roxygen2`를 사용해서 함수 문서를 생성하는 것과 같다. `roxygen2` 블록 (`#'`로 시작)과 태그 (`@`로 시작) 를 사용한다.
작업흐름은 동일하다:


1. roxygen 주석을 `.R` 파일에 추가한다.

1. `devtools::document()` (혹은 RStudio에서 Ctrl/Cmd + Shift + D 단축키 누름) 명령어를 
  실행해서 roxygen 주석을 `.Rd` 파일로 변환한다.

1. `NAMESPACE`를 살펴보고 테스트를 실행해서 사양서가 올바른지 점검한다.

1. 올바른 함수를 내보낼때까지 깔끔히 하고 과정을 반복한다.


## 내보내기 (Exports) {#exports}

작성한 팩키지가 밖에서도 함수가 유용하게 사용되려면,
함수를 __내보내야(export)__만 된다.
`devtools::create()` 명령어로 신규 팩키지를 생성하면,
임시 `NAMESPACE`를 만들어서 `.` (마침표)로 시작되지 않는 팩키지에 있는 모든 것을 내보낸다.
로컬 컴퓨터에서만 작업한다면, 팩키지에 모든 것을 내보내는 것도 좋다.
하지만, 다른 사람들과 작성한 팩키지를 공유할 계획이 있다면, 꼭 필요한 함수만 내보는 것이 정말 좋은 접근법이 된다. 이런 과정을 통해 다른 팩키지와 충돌날 가능성을 줄인다.

객체를 내보내려면, roxygen 블록에 `@export` 태그를 넣는다. 예를 들어:

```{r}
#' @export
foo <- function(x, y, z) {
  ...
}
```

상기 코드블록은 객체 유형에 따라 `export()`, `exportMethods()`, `exportClass()`, `S3method()` 을 생성한다.

다른 사용자가 사용하고 싶은 함수를 내보낸다.
내보내기한 함수는 문서화되어야 되고, 인터페이스를 변경할 때 주의해야 한다 - 다른 사람이 함수를 사용하고 있기 때문이다! 일반적으로,
너무 많이 내보내는 것보다 너무 적게 내보내는 것이 낫다.
전에 내보내지 않은 것을 내보내는 것은 쉽다; 함수 내보내는 것을 멈추기는 어려운데 이유는 기존 코드를 망가뜨릴 수 있기 때문이다.
항상 지나치다 싶을 정도로 조심하고 단순화하라.
사용자가 익숙한 무언가를 빼앗기 보다 사용자에게 더 많은 기능을 부여하는 것이 더 쉽다.

저자가 믿기로는 폭넓은 사용자를 갖는 팩키지는 단지 하나에 집중하고 그것을 잘 한다.
팩키지에 있는 모는 함수는 단일 문제(혹은 매우 밀접하게 연관된 문제 집합)에 연관되어 있어야 된다. 그 목적에 연관되지 않는 어떤 함수도 내보내기해서는 안된다.
예를 들어, 저자가 집필한 대부분의 팩키지는 `utils.R` 파일을 갖는데 
작은 함수가 다수 포함되어 있는데 저자에게는 도움이 되지만, 팩키지의 핵심 목적에는 부합하지 않는다. 저자는 절대로 이러한 함수를 내보내지 않는다.

```{r}
# Defaults for NULL values
`%||%` <- function(a, b) if (is.null(a)) b else a

# Remove NULLs from a list
compact <- function(x) {
  x[!vapply(x, is.null, logical(1))]
}
```

앞의 사례를 통해서, 만약 본인을 위한 목적으로 팩키지를 생성한다면,
너무 규율을 잡아 철저히 하는 것이 그다지 중요하지 않다.
작성한 팩키지에 무엇이 담겨있는지 알고 있기 때문에,
본인 생각에 유용한 함수를 꾸러미로 모아 로컬에 "잡동산이(misc)" 팩키지를 생성해도 좋다.
하지만, 그런 팩키지를 외부에 출시하는 것은 반대한다.

다음 절에서 S3, S4, RC 를 사용한다면 무엇을 내보낼지 기술한다.

### S3  {#export-s3}

만약 다른 사용자가 S3 클래스 인스턴스를 생성하려고 한다면, `@export` 태그로 생성자 함수를 내보낸다.
S3 제네릭은 정규 R 함수에 불과하다. 그래서 `@export`를 사용해서 함수처럼 내보낸다.

S3 메쏘드는 가장 복잡한 경우를 표현하는데 이유는 4가지 다른 시나리오가 있기 때문이다:


* 내보내기 제네릭에 대한 메쏘드: 모든 메쏘드를 내보낸다.

* 내부 제네릭에 대한 메쏘드: 기술적으로 이런 메쏘드를 내보내기할 필요는 없다.
  하지만, 작성한 모든 S3 메쏘드를 내보내는데 저자는 주저하지 않는다.
  왜냐하면 더 간단하고 찾기 힘든 버그를 신규로 만들어낼 것 같지 않다.
  `devtools::missing_s3()`를 사용해서 내보내기를 잊은 모든 S3 메쏘드를 목록으로 만든다.

* require 팩키지에 있는 제네릭에 대한 메쏘드: 
  제네릭을 가져와서 (아래 참조) 메쏘드를 내보낼 필요가 있다. 

* suggest 팩키지에 있는 제네릭에 대한 메쏘드: 네임스페이스 지시어는 이용가능한
  함수를 참조해야 되어서, suggest 패키지를 참조할 수는 없다.
  팩키지 후크(hook)과 코드를 사용해서 실행될 때 추가하는 것은 가능하다.
  하지만, 그 자체로 충분히 복잡해서 현재 저자는 이 방법을 추천하지는 않는다.
  대신에, 상기 시나리오를 피하는 방식으로 팩키지 의존성을 설계해야 된다.

### S4 {#export-s4}

S4 클래스: 다른 사용자가 작성한 클래스를 확장하려고 한다면, `@export` 태그로 내보내기 하라. 
만약 다른 사용자로 하여금 클래스 인스턴스 생성은 가능하지만, 확장하지 못하게 하려면, 
`@export` 태그로 클래스가 아닌 생성자 함수로 내보낸다.


```{r, eval = FALSE}
# Can extend and create with new("A", ...)
#' @export
setClass("A")

# Can extend and create with new("B", ...). You can use B()
# to construct instances in your own code, but others can not
#' @export
B <- setClass("B")

# Can create with C(...) and new("C", ...), but can't create
# a subclass that extends C
#' @export C
C <- setClass("C")

# Can extend and create with D(...) or new("D", ...)
#' @export D
#' @exportClass D
D <- setClass("D")
```


S4 제네릭: 만약 제네릭을 외부에서도 사용가능하게 하려면 `@export` 태그를 사용한다.

S4 메쏘드: `@export` 태그로 정의하지 않은 제네릭에 대한 메쏘드를 내보내면 된다.
하지만, `@export`태로 모든 메쏘드를 내보내는 것이 저자 생각에는 좋다:
이런 방식으로 하면 제네릭을 생성했는지 않았는지 기억할 필요가 없다.

### RC {#export-rc}

S4 클래스에 사용된 원칙이 여기서도 동일하게 적용된다.
주목할 점은 RC가 현재 구현된 방식 때문에, 일반적으로 작성한 클래스를 팩키지 외부로 확장하는 것은 불가능하다.

### 데이터 {#export-data}

[data](#data)에서 학습할 예정으로, `data/` 디렉토리에 있는 파일은 일반적인 네임스페이스 메카니즘을 사용하지 않아서 내보내기할 필요가 없다. 

## 가져오기(Imports) {#imports}

`::`을 사용하지 않고 `NAMESPACE`를 사용해서 작성한 팩키지가 어떤 외부 함수를 사용할지 제어한다.

`DESCRIPTION` (`Imports` 필드를 통해)와 `NAMESPACE` (import 지시어를 통해) 둘다 가져오기에 관여해서 혼란스럽다. 불행한 명칭 선택에 기인한다.
`Imports` 필드는 정말 네임스페이스로 가져오는 함수와 아무 관련이 없다: 작성한 팩키지가 있을 때 팩키지가 확실히 설치되게만 하는 역할을 한다. 함수를 이용가능하게 하지는 않는다.
팩키지가 부착되던 말던 관계없이 함수를 정확하게 가져오기만 하면 된다.


`Depends`는 단지 사용자를 위한 편의사항이다: 만약 작성한 팩키지가 부착되면, `Depends` 목록에 있는 모든 팩키지를 부착한다. 만약 작성한 팩키지가 적재되면, `Depends`에 있는 팩키지는 적재되지만 부착되지는 않는다.
그래서, `::` 으로 함수 명칭에 자격을 부여하거나 혹은 구체적으로 함수를 가져올 필요가 있다.

`NAMESPACE`가 아닌 `DESCRIPTION` 파일 `Imports`에 팩키지가 등재되는 것이 일반적이다.
사실, 이 방법이 저자가 추천하는 방법이다: `DESCRIPTION`에 팩키지 목록을 올려서 설치되게 한다.
그리고 나서 항상 명시적으로 `pkg::fun()`으로 참조한다.
명시적으로 하지 못할 강력한 사유가 있지 않다면, 명시적으로 표현하는 것이 더 낫다.
작성하는 것이 일부 작업을 증대시키지만, 향후 코드를 다시 살펴볼 때 훨씬 더 높은 가독성을 제공한다.
그 반대는 사실이 아니다. `NAMESPACE`에 언급된 모든 팩키지는 `Imports` 혹은 `Depends` 필드에 나타나야 된다.

### R 함수 {#import-r}

만약 또다른 팩키지로부터 일부 함수만 사용한다면,
`DESCRIPTION` 파일 `Imports:` 필드에 팩키지 명칭을 언급하고, `pkg::fun()` 처럼 `::`을 사용해서 
명시적으로 함수를 호출하는 방식을 저자는 추천한다.

만약 반복적으로 함수를 사용한다면, `@importFrom pgk fun`으로 함수를 가져와서 `::` 사용을 회피할 수 있다.
이러한 방식은 일부 성능 향상되는 기능도 있다. 왜냐하면 `::`을 사용하면 함수 평가시간을 대략 5 µs 증대시킨다. 

대안으로, 또다른 팩키지로부터 함수를 대량으로 사용한다면, 
`@import package` 를 사용해서 팩키지 모든 함수를 가져올 수 있다.
이 방식은 가장 추천하지 않는데 이유는 코드 가독성을 현저히 떨어뜨리기 때문이다 (함수가 나온 출처를 분간할 수 없다). 그리고 만약 `@import` 태그로 많은 팩키지를 가져온다면, 함수 명칭이 충돌할 가능성이 높아진다.


### S3 {#import-s3}

S3 제네릭은 단지 함수에 불과하다. 그래서 함수에 동일한 규칙이 적용된다.
S3 메쏘드는 항상 제네릭을 동반한다. 그래서 제네릭에 접근할 수 있기만 하면 (명시적이든 암묵적이든), 메쏘드도 이용가능하다. 다른 말로 표현해서, S3 메쏘드에 대해서 특별한 어떤 것도 수행할 필요가 없다.
제네릭을 가져오기만 하면, 모든 메쏘드도 이용가능하다.

### S4 {#import-s4}

또 다른 팩키지에 정의된 클래스를 사용하기 위해서, 가져온 클래스에서 상속받은 클래스 옆에, 
혹은 가져온 클래스에 대한 제네릭을 구현한 메쏘드 옆에 `@importClassesFrom package ClassA ClassB ...` 태그를 위치한다.

또다른 팩키지에 정의된 제네릭을 사용하기 위해서, `@importMethodsFrom package GenericA GenericB ...` 태그를 위치한다.

S4가 메쏘드 팩키지에 구현되기 때문에, 이용가능하다는 것을 확실히 할 필요가 있다.
이것을 간과하기 쉬운데 이유는 인터랙티브하게 작업할 때 검색경로에 팩키지 메쏘드가 항상 이용가능한 반면에,
`Rscript`로는 자동적으로 적재되지 않기 때문이다. `Rscript`는 명령라인 인터페이스에서 R을 실행하는데 자주 사용되는 도구다.


  * R 3.2.0 이전: `DESCRIPTION` 파일에 `Depends: methods`.  \
    R 3.2.0 이후: `DESCRIPTION` 파일에 `Imports: methods`.
  
  * `methods`로부터 많은 함수를 사용하기 때문에, 아마도 전체 팩키지를 가져오고 싶을 것이다:
    
    ```{r, eval = FALSE}
    #' @import methods
    NULL
    ```
    
    혹은 단지 가장 자주 사용되는 함수만 가져오고 싶을 것이다:
    
    ```{r, eval = FALSE}
    #' @importFrom methods setClass setGeneric setMethod setRefClass
    NULL
    ```
  
    여기서 "NULL" 문서화해서 해당 지시어가 단지 함수 하나만 적용되지 않는다는 것을 명시했다.
    어디에 위치하든 문제가 되지 않는다. 하지만 [documenting packages](#man-packages)에 기술되듯이 
    만약 팩키지 문서가 있다면 그곳이 위치시킬 적절한 장소가 된다.
    

### 컴파일된 함수 {#import-src}

R에 C/C++ 함수를 이용가능하게 만들려면, [compiled code](#src)를 참조한다.
 
